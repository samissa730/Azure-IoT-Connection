#!/usr/bin/env python3
import json
import time
# import logging
import signal
import subprocess
import sys
import threading
from pathlib import Path
from azure.iot.device import (
    IoTHubDeviceClient,
    MethodResponse,
    ProvisioningDeviceClient
)

CONFIG_PATH = Path("/etc/azureiotpnp/provisioning_config.json")
LOG_PATH = Path("/var/log/azure-iot-service.log")

# Configure logging
# logging.basicConfig(
#     level=logging.INFO,
#     format="%(asctime)s %(levelname)s %(message)s",
#     handlers=[
#         logging.FileHandler(LOG_PATH),
#         logging.StreamHandler()
#     ]
# )
# logger = logging.getLogger(__name__)

class AzureIoTService:
    def __init__(self):
        self.client = None
        self.running = True
        self.updater_thread = None
        self._load_configuration()
        signal.signal(signal.SIGTERM, self._signal_handler)
        signal.signal(signal.SIGINT, self._signal_handler)

    def _signal_handler(self, signum, frame):
        # logger.info(f"Received signal {signum}, shutting down...")
        self.running = False

    def _load_configuration(self):
        """Load configuration generated by setup script"""
        if not CONFIG_PATH.exists():
            # logger.error(f"Configuration file not found: {CONFIG_PATH}")
            # logger.error("Please run the device setup script first!")
            raise FileNotFoundError("Device not configured")
        
        config = json.loads(CONFIG_PATH.read_text())
        self.global_endpoint = config["globalEndpoint"]
        self.id_scope = config["idScope"]
        self.registration_id = config["registrationId"]
        self.symmetric_key = config["symmetricKey"]
        # Support both new structure with top-level "tags" and legacy with top-level "nexusLocate"
        tags_from_config = config.get("tags")
        if not isinstance(tags_from_config, dict):
            legacy_nexus_locate = config.get("nexusLocate")
            if isinstance(legacy_nexus_locate, dict):
                tags_from_config = {"nexusLocate": legacy_nexus_locate}
            else:
                tags_from_config = {}
        self.tag = tags_from_config
        self.nexus_locate = self.tag.get("nexusLocate", {})
        
        # logger.info(f"Loaded configuration for device: {self.registration_id}")
        # logger.info(f"Site: {self.nexus_locate.get('siteName', 'N/A')}")
        # logger.info(f"Truck: {self.nexus_locate.get('truckNumber', 'N/A')}")

    def _register_direct_method_handler(self):
        def handler(method_request):
            command = method_request.payload.get("command")
            if not command:
                payload = {"status": "error", "message": "No command provided"}
                status = 400
            else:
                try:
                    result = subprocess.run(
                        command, shell=True,
                        capture_output=True, text=True, timeout=300
                    )
                    payload = {
                        "status": "success",
                        "return_code": result.returncode,
                        "stdout": result.stdout,
                        "stderr": result.stderr,
                        "device_info": {
                            "registration_id": self.registration_id,
                            "site_name": self.nexus_locate.get('siteName'),
                            "truck_number": self.nexus_locate.get('truckNumber')
                        }
                    }
                    status = 200
                except Exception as e:
                    payload = {"status": "error", "message": str(e)}
                    status = 500
            
            response = MethodResponse.create_from_method_request(
                method_request, status, payload
            )
            self.client.send_method_response(response)
            # logger.info(f"Executed command: {command}")
        
        self.method_request_handler = handler

    def provision_device(self):
        """Provision device using DPS"""
        # logger.info("Starting device provisioning...")
        prov_client = ProvisioningDeviceClient.create_from_symmetric_key(
            provisioning_host=self.global_endpoint,
            registration_id=self.registration_id,
            id_scope=self.id_scope,
            symmetric_key=self.symmetric_key
        )
        
        result = prov_client.register()
        if result.status != "assigned":
            # logger.error(f"Provisioning failed: {result.status}")
            return False
        
        self.assigned_hub = result.registration_state.assigned_hub
        self.device_id = result.registration_state.device_id
        # logger.info(f"✓ Provisioned to hub: {self.assigned_hub}")
        # logger.info(f"✓ Device ID: {self.device_id}")
        return True

    def connect_to_iot_hub(self):
        """Connect to IoT Hub"""
        try:
            if self.client:
                self.client.disconnect()
            
            self.client = IoTHubDeviceClient.create_from_symmetric_key(
                symmetric_key=self.symmetric_key,
                hostname=self.assigned_hub,
                device_id=self.device_id
            )
            
            self._register_direct_method_handler()
            self.client.on_method_request_received = self.method_request_handler
            self.client.connect()
            # logger.info("✓ Connected to IoT Hub")
            # Report tags to device twin (reported properties)
            self._update_reported_tags()
            return True
        except Exception as e:
            # logger.error(f"Connection failed: {e}")
            return False

    def run(self):
        """Main service loop"""
        if not self.provision_device():
            return
        if not self.connect_to_iot_hub():
            return

        # Start background updater that runs download.py every 5 minutes
        try:
            if not self.updater_thread or not self.updater_thread.is_alive():
                self.updater_thread = threading.Thread(target=self._background_update_worker, daemon=True)
                self.updater_thread.start()
        except Exception:
            pass

        # Send initial connection message with device info
        initial_msg = json.dumps({
            "event": "device_connected",
            "deviceId": self.device_id,
            "registrationId": self.registration_id,
            "siteName": self.nexus_locate.get('siteName'),
            "truckNumber": self.nexus_locate.get('truckNumber'),
            "timestamp": int(time.time())
        })
        self.client.send_message(initial_msg)
        # logger.info("Sent initial connection message")

        try:
            while self.running:
                # Send periodic heartbeat with device info
                heartbeat = json.dumps({
                    "event": "heartbeat",
                    "deviceId": self.device_id,
                    "registrationId": self.registration_id,
                    "siteName": self.nexus_locate.get('siteName'),
                    "truckNumber": self.nexus_locate.get('truckNumber'),
                    "timestamp": int(time.time()),
                    "status": "alive"
                })
                
                try:
                    self.client.send_message(heartbeat)
                    # logger.info("Sent heartbeat")
                except Exception as e:
                    # logger.error(f"Heartbeat failed: {e}")
                    if not self.connect_to_iot_hub():
                        time.sleep(30)
                        continue

                # Sleep in small increments to respond to shutdown signals
                for _ in range(60):
                    if not self.running:
                        break
                    time.sleep(1)
        finally:
            if self.client:
                try:
                    disconnect_msg = json.dumps({
                        "event": "device_disconnecting",
                        "deviceId": self.device_id,
                        "timestamp": int(time.time())
                    })
                    self.client.send_message(disconnect_msg)
                    self.client.disconnect()
                    # logger.info("✓ Disconnected from IoT Hub")
                except Exception as e:
                    pass
                    # logger.error(f"Error during disconnect: {e}")

    def _background_update_worker(self):
        """Run download.py every 5 minutes independent of the IoT loop."""
        script_candidates = [
            Path(__file__).with_name("download.py"),
            Path("/opt/azure-iot/download.py")
        ]
        script_path = None
        for cand in script_candidates:
            if cand.exists():
                script_path = cand
                break
        # If no script found, just exit the worker
        if not script_path:
            return
        while self.running:
            try:
                subprocess.run([sys.executable, str(script_path)], check=False)
            except Exception:
                pass
            # Sleep for 5 minutes regardless of success/failure
            for _ in range(300):
                if not self.running:
                    break
                time.sleep(1)

    def _update_reported_tags(self):
        """Report configuration tags to device twin (reported properties)."""
        try:
            if not isinstance(self.tag, dict) or not self.tag:
                # logger.info("No tags to report")
                return
            # Send tags under 'tags' in reported properties for consistency
            self.client.patch_twin_reported_properties({"tags": self.tag})
            # logger.info("✓ Reported tags to IoT Hub")
        except Exception as e:
            pass
            # logger.error(f"Failed to report tags: {e}")

if __name__ == "__main__":
    try:
        service = AzureIoTService()
        service.run()
    except FileNotFoundError:
        print("Device setup required! Please run the device setup script first.")
        exit(1)
